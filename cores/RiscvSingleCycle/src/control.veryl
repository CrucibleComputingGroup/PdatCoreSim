// Control Unit for single-cycle RISC-V processor
// Decodes instructions and generates control signals
module control (
    instruction: input logic<32>,

    // Control signals
    branch: output logic,
    jump: output logic,
    mem_read: output logic,
    mem_write: output logic,
    mem_to_reg: output logic,
    alu_src: output logic,
    alu_a_src: output logic<2>,
    reg_write: output logic,
    alu_op: output logic<4>,
    imm_sel: output logic<3>,

    // Branch condition signals
    funct3: output logic<3>,
    pc_src: output logic<2>
) {
    // Instruction fields
    var opcode: logic<7>;
    var funct3_field: logic<3>;
    var funct7: logic<7>;

    assign opcode = instruction[6:0];
    assign funct3_field = instruction[14:12];
    assign funct7 = instruction[31:25];

    // Opcodes
    const OP_LUI: logic<7> = 7'b0110111;
    const OP_AUIPC: logic<7> = 7'b0010111;
    const OP_JAL: logic<7> = 7'b1101111;
    const OP_JALR: logic<7> = 7'b1100111;
    const OP_BRANCH: logic<7> = 7'b1100011;
    const OP_LOAD: logic<7> = 7'b0000011;
    const OP_STORE: logic<7> = 7'b0100011;
    const OP_IMM: logic<7> = 7'b0010011;
    const OP_REG: logic<7> = 7'b0110011;

    // ALU operation codes (from alu.veryl)
    const ALU_ADD: logic<4> = 4'b0000;
    const ALU_SUB: logic<4> = 4'b0001;
    const ALU_SLL: logic<4> = 4'b0010;
    const ALU_SLT: logic<4> = 4'b0011;
    const ALU_SLTU: logic<4> = 4'b0100;
    const ALU_XOR: logic<4> = 4'b0101;
    const ALU_SRL: logic<4> = 4'b0110;
    const ALU_SRA: logic<4> = 4'b0111;
    const ALU_OR: logic<4> = 4'b1000;
    const ALU_AND: logic<4> = 4'b1001;

    // Immediate selection codes (from immgen.veryl)
    const IMM_I: logic<3> = 3'b000;
    const IMM_S: logic<3> = 3'b001;
    const IMM_B: logic<3> = 3'b010;
    const IMM_U: logic<3> = 3'b011;
    const IMM_J: logic<3> = 3'b100;

    // PC source selection
    const PC_PLUS4: logic<2> = 2'b00;
    const PC_BRANCH: logic<2> = 2'b01;
    const PC_JALR: logic<2> = 2'b10;

    // ALU A source selection
    const ALU_A_RS1: logic<2> = 2'b00;
    const ALU_A_PC: logic<2> = 2'b01;
    const ALU_A_ZERO: logic<2> = 2'b10;

    var ctrl_branch: logic;
    var ctrl_jump: logic;
    var ctrl_mem_read: logic;
    var ctrl_mem_write: logic;
    var ctrl_mem_to_reg: logic;
    var ctrl_alu_src: logic;
    var ctrl_alu_a_src: logic<2>;
    var ctrl_reg_write: logic;
    var ctrl_alu_op: logic<4>;
    var ctrl_imm_sel: logic<3>;
    var ctrl_pc_src: logic<2>;

    always_comb {
        // Default values
        ctrl_branch = 0;
        ctrl_jump = 0;
        ctrl_mem_read = 0;
        ctrl_mem_write = 0;
        ctrl_mem_to_reg = 0;
        ctrl_alu_src = 0;
        ctrl_alu_a_src = ALU_A_RS1;
        ctrl_reg_write = 0;
        ctrl_alu_op = ALU_ADD;
        ctrl_imm_sel = IMM_I;
        ctrl_pc_src = PC_PLUS4;

        case opcode {
            OP_LUI: {
                // LUI: Load Upper Immediate
                ctrl_reg_write = 1;
                ctrl_imm_sel = IMM_U;
                ctrl_alu_src = 1;
                ctrl_alu_a_src = ALU_A_ZERO; // 0 + imm_u
                ctrl_alu_op = ALU_ADD;
            }
            OP_AUIPC: {
                // AUIPC: Add Upper Immediate to PC
                ctrl_reg_write = 1;
                ctrl_imm_sel = IMM_U;
                ctrl_alu_src = 1;
                ctrl_alu_a_src = ALU_A_PC; // PC + imm_u
                ctrl_alu_op = ALU_ADD;
            }
            OP_JAL: {
                // JAL: Jump and Link
                ctrl_jump = 1;
                ctrl_reg_write = 1;
                ctrl_imm_sel = IMM_J;
                ctrl_pc_src = PC_BRANCH;
            }
            OP_JALR: {
                // JALR: Jump and Link Register
                ctrl_jump = 1;
                ctrl_reg_write = 1;
                ctrl_imm_sel = IMM_I;
                ctrl_alu_src = 1;
                ctrl_pc_src = PC_JALR;
            }
            OP_BRANCH: {
                // Branch instructions
                ctrl_branch = 1;
                ctrl_imm_sel = IMM_B;
                ctrl_alu_op = ALU_SUB;
            }
            OP_LOAD: {
                // Load instructions
                ctrl_mem_read = 1;
                ctrl_mem_to_reg = 1;
                ctrl_reg_write = 1;
                ctrl_alu_src = 1;
                ctrl_imm_sel = IMM_I;
                ctrl_alu_op = ALU_ADD;
            }
            OP_STORE: {
                // Store instructions
                ctrl_mem_write = 1;
                ctrl_alu_src = 1;
                ctrl_imm_sel = IMM_S;
                ctrl_alu_op = ALU_ADD;
            }
            OP_IMM: {
                // Immediate ALU operations
                ctrl_reg_write = 1;
                ctrl_alu_src = 1;
                ctrl_imm_sel = IMM_I;

                case funct3_field {
                    3'b000: ctrl_alu_op = ALU_ADD;    // ADDI
                    3'b010: ctrl_alu_op = ALU_SLT;    // SLTI
                    3'b011: ctrl_alu_op = ALU_SLTU;   // SLTIU
                    3'b100: ctrl_alu_op = ALU_XOR;    // XORI
                    3'b110: ctrl_alu_op = ALU_OR;     // ORI
                    3'b111: ctrl_alu_op = ALU_AND;    // ANDI
                    3'b001: ctrl_alu_op = ALU_SLL;    // SLLI
                    3'b101: {
                        // SRLI or SRAI
                        if funct7[5] {
                            ctrl_alu_op = ALU_SRA;
                        } else {
                            ctrl_alu_op = ALU_SRL;
                        }
                    }
                    default: ctrl_alu_op = ALU_ADD;
                }
            }
            OP_REG: {
                // Register ALU operations
                ctrl_reg_write = 1;

                case funct3_field {
                    3'b000: {
                        // ADD or SUB
                        if funct7[5] {
                            ctrl_alu_op = ALU_SUB;
                        } else {
                            ctrl_alu_op = ALU_ADD;
                        }
                    }
                    3'b001: ctrl_alu_op = ALU_SLL;    // SLL
                    3'b010: ctrl_alu_op = ALU_SLT;    // SLT
                    3'b011: ctrl_alu_op = ALU_SLTU;   // SLTU
                    3'b100: ctrl_alu_op = ALU_XOR;    // XOR
                    3'b101: {
                        // SRL or SRA
                        if funct7[5] {
                            ctrl_alu_op = ALU_SRA;
                        } else {
                            ctrl_alu_op = ALU_SRL;
                        }
                    }
                    3'b110: ctrl_alu_op = ALU_OR;     // OR
                    3'b111: ctrl_alu_op = ALU_AND;    // AND
                    default: ctrl_alu_op = ALU_ADD;
                }
            }
            default: {
                // Invalid instruction - all signals stay at default
            }
        }
    }

    assign branch = ctrl_branch;
    assign jump = ctrl_jump;
    assign mem_read = ctrl_mem_read;
    assign mem_write = ctrl_mem_write;
    assign mem_to_reg = ctrl_mem_to_reg;
    assign alu_src = ctrl_alu_src;
    assign alu_a_src = ctrl_alu_a_src;
    assign reg_write = ctrl_reg_write;
    assign alu_op = ctrl_alu_op;
    assign imm_sel = ctrl_imm_sel;
    assign funct3 = funct3_field;
    assign pc_src = ctrl_pc_src;
}
